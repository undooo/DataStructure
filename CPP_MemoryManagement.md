# C++的内存管理

C/C++程序运行时所需空间可分为两大部分：固定部分和可变部分

## 固定部分
- 代码区： 存储二进制代码
- 数据区： 全局变量、静态变量、常量等

## 可变部分
- 栈区：运行方法的形参、局部变量、返回值、递归栈空间。由系统自动分配回收

- 堆区：动态开辟的空间，存放new出来的对象在堆区中的真实数据。需要手动回收

32位编译器的指针占4个比特，原因是2^32大约为4个G的大小，可以寻址4G的内存大小。

64位编译器的指针占8个比特，原因是4个比特不足以做到全址扫描。

## 内存对齐
内存对齐机制的原因：
1. 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，可能会抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
2. 硬件原因：内存对齐以后，CPU的访问速度会大大提升

CPU在读取内存时不是一次读取单个字节，而是按块读取，块的大小可以是2，4，8，16。

内存对齐的话例如：
0：char 1 2 3 		4:int 5:int 6:int 7:int
可以一次全部读取int的4个字节

不对齐：
0:char 1:int 2:int 3:int 4:int 5 6 7 
需要两次寻址、一次合并

可以看出，内存对齐在一定程度上会浪费内存资源，但是考虑到目前计算机内存资源一般都较为充足，所以我们希望能够提高运行速度。
