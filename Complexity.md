# 时间复杂度
是一个函数，定性的描述该算法的运行时间，通常会估算算法的操作单元数量来表示程序消耗的时间

## 大O
算法导论中的解释：大O表示上界，即最坏情况下的运行时间
 
业内默认规定是一般情况下，一个算法的一般情况，而不是上界

## 数据规模差异
对于算法的选择，要考虑数据规模的差异，并不是时间复杂度越低就越好，例如，当需要考虑到数据规模时，在规模很小的情况下，$ O(n^2) $ 的效果可能更好。


## 化简

- 去掉加法常数项
- 去掉常数系数
- 只保留最高项

## O(logn)
忽略对底数的描述，原因在于，不同的底数可以通过乘以一个常数相互转换

## 硬件配置
- 1Hz = 1/s , 代表CPU的一次脉冲，可以理解为一次改变状态，也叫时钟周期，称之为Hz

- 1MHz = 10^6 Hz

- 1GHz = 10^3 MHz

关于计算机执行指令的耗时问题：
- CPU执行不同指令所需时间不同，例如加法和乘法的操作耗时就有区别（一个加法用一个门电路，乘法用多个门电路）
- 大多数计算机有缓存技术，因此访问相同地址和不相邻元素所需时间也不同
- 计算机同时运行多个程序，每个程序中有不同的进程线程在争抢资源

## 递归算法的时间复杂度

复杂度：递归的次数*每次递归中的操作次数

## 空间复杂度

运行时占用内存的大小

以斐波那契数列为例

``` c++

int function1(int x){
	if(i<=0) return 0;
	if(i == 1) return 1;
	return function(x-1) + function(x-2);
}

```
时间复杂度是指数级的，原因在于这是一颗深度为n的树，最多有$ 2^k -1 $ 次个节点。

可以进行一定的优化，减少递归的调用次数

``` c++
int function(int n,int first=0, int second=1){
	if(n<=0){
		return 0;
	}
	if(n == 1){
		return second;
	}
	return function(n-1,second,first+second);	
}


```
此情况下，被优化到了 O(n)
总结：空间复杂度 = 每次递归的空间复杂度*递归深度。

每次递归所需的空间都会被压到调用栈里，这个栈的最大长度就是栈的深度